# Data Structure HW2 - 軟體定義網路路由路徑更新

## 作業描述
本作業實作軟體定義網路(SDN)環境中的路由路徑更新演算法，目標是在資料中心網路中最小化網路更新的回合數，確保網路更新的安全性和效率。

## 專案背景
- **軟體定義網路(SDN)**：集中式控制器管理分散式交換器
- **資料中心環境**：多個伺服器透過交換器連接
- **路由更新挑戰**：非同步更新可能導致封包丟失或路由循環
- **解決方案**：基於回合的更新演算法(Round-based update)

## 專案目標
- **主要目標**：最小化網路更新的回合數
- **核心挑戰**：在保證網路安全的前提下，用最少的回合完成路由更新
- **成功條件**：所有節點都成功更新到新路由路徑

## 問題分析
- 給定舊路由路徑和新路由路徑
- 需要將網路從舊路徑安全地更新到新路徑
- 使用基於回合的更新演算法，分為捷徑階段和修剪階段
- 每個回合只能更新不衝突的節點

## 實作方法

### 核心演算法：基於共同路徑的逐步更新

本實作採用**基於共同路徑的逐步更新**方法，通過分析舊路徑和新路徑的共同部分，實現最小化更新回合數的目標。

#### 1. 節點分類與狀態管理
```c
// 節點類型分類
char point[n];  // cp=0, op=1, np=2, >=3表示已更新
int ct_op_np[2] = {0};  // [0]:OP計數, [1]:NP計數
```

**節點分類策略**：
- **共同點(CP)**：兩個路徑都存在的節點，標記為0
- **舊點(OP)**：只在舊路徑存在的節點，標記為1
- **新點(NP)**：只在新路徑存在的節點，標記為2
- **已更新**：標記值≥3表示該節點已完成更新

#### 2. 共同路徑追蹤系統
```c
// 建立共同路徑的序列編號
int path[3][n];  // [0]:舊路徑, [1]:新路徑, [2]:共同路徑序列
int count_cp_old = 0;
```

**共同路徑管理**：
- 使用`path[2]`陣列記錄共同點在舊路徑中的序列位置
- 通過`count_cp_old`計數器為共同點分配序列號
- 追蹤共同路徑的變化，識別哪些節點離開了共同路徑

#### 3. 三階段更新策略

**第一階段：新點更新**
```c
// 優先更新新點(NP)
if(point[j]==2){ // NP
    step[0][j]=path[1][j];
    point[j]+=3; // 標記為已更新
    update_count++;
}
```

**第二階段：共同路徑前跳更新**
```c
// 更新在共同路徑中向前跳躍的節點
if(path[2][end]>path[2][j]){ // 如果向前跳躍
    step[count_output-3][j]=path[1][j];
    point[j]+=3; // 標記為已更新
    update_count++;
}
```

**第三階段：非共同路徑更新**
```c
// 更新不在共同路徑中的共同點
if(path[2][j]==-1 && point[j]==0){ // CP且不在共同路徑中
    step[count_output-3][j]=path[1][j];
    point[j]+=3; // 標記為已更新
    update_count++;
}
```

#### 4. 動態回合管理
```c
int count_output = 2;  // 初始狀態 + 最終狀態
int **step = malloc(sizeof(int*));  // 動態步驟陣列
```

**回合控制機制**：
- 動態分配步驟陣列，每回合重新分配記憶體
- 追蹤更新進度，確保所有節點都被正確更新
- 智能檢測更新完成條件

#### 5. 關鍵演算法優勢
- **最小化回合數**：通過分析共同路徑結構，減少不必要的更新回合
- **衝突避免**：確保更新過程中不會產生路由循環
- **記憶體效率**：使用動態陣列管理，避免固定大小限制
- **狀態追蹤**：精確追蹤每個節點的更新狀態

#### 6. 實作細節

**動態記憶體管理**：
```c
// 動態擴展步驟陣列
step = realloc(step, (count_output-2) * sizeof(int*));
step[count_output-3] = malloc(n * sizeof(int));
```

**共同路徑重建**：
```c
// 重建共同路徑序列
while(tmp_pt > -1){
    if(point[tmp_pt]%3==0){
        path[2][tmp_pt]=count_cp_old++;
        count_leave--;
    }
    tmp_pt=step[count_output-3][tmp_pt];
}
```

**更新完成檢測**：
```c
// 檢查是否所有節點都已更新
while(update_count<n-1){
    // 繼續更新過程
}
```

## 輸入格式
```
n                    // 節點數量
舊路徑 (n個數字，-1表示空值)
新路徑 (n個數字，-1表示空值)
```

## 輸出格式
```
總回合數
第1回合的路徑狀態
第2回合的路徑狀態
...
最終路徑狀態
```

## 範例
**輸入**：
```
12
7 2 9 10 -1 -1 -1 8 1 3 11 -1
4 6 1 2 5 3 11 -1 -1 -1 -1 -1
```

**輸出**：
```
6
7 2 9 10 -1 -1 -1 8 1 3 11 -1
7 2 9 10 5 3 11 8 1 3 11 -1
4 2 9 10 5 3 11 8 1 3 11 -1
4 6 1 10 5 3 11 8 1 3 11 -1
4 6 1 2 5 3 11 8 1 3 11 -1
4 6 1 2 5 3 11 -1 -1 -1 -1 -1
```

## 評分標準
- **成績與更新回合數成反比**：回合數越少，分數越高
- **基本分數**：75分（在截止日期前提交）
- **績效排名獎勵**：根據回合數優化程度給予額外分數
- **作業助理獎勵**：+10分（超級截止日期前提交）

## 檔案說明
- `411410006_hw2.c` - 主要實作檔案
- `input sample.txt` - 輸入範例
- `samples-HW2/` - 測試資料夾
- `program2.pdf` - 作業說明文件

## 技術重點
- **基於回合的更新演算法**：捷徑階段和修剪階段的交替執行
- **節點分類與狀態管理**：CP、OP、NP節點的分類和追蹤
- **衝突檢測與避免**：確保更新過程中的網路安全性
- **動態記憶體管理**：使用malloc/realloc管理更新步驟
- **回合優化**：最小化更新回合數的演算法設計
- **網路安全更新**：避免封包丟失和路由循環

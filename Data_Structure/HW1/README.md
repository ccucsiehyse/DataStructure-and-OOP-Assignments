# Data Structure HW1 - 滾動球迷宮

## 作業描述
本作業實作「滾動球迷宮」演算法，需要同時控制兩個球在迷宮中移動，讓它們各自到達指定的目的地洞。這是一個複雜的同步路徑規劃問題。

## 專案目標
- **主要目標**：最小化完成時間（動作次數）
- **核心挑戰**：同時控制兩個球，讓它們各自到達一個目的地洞
- **成功條件**：一旦球到達目的地，它會填滿該洞並消失，該目的地不會再被填滿

## 問題分析
- 給定一個 `n×n` 迷宮矩陣，其中 `1` 代表牆壁，`0` 代表可通行路徑
- 迷宮包含兩顆起始球與兩個目的地洞
- 每個動作會讓兩個球同步移動（上、下、左、右）
- 球不能穿牆，但可以重疊
- 目標是找到最少的動作序列

## 實作方法

### 核心演算法：分離式路徑搜尋 + 路徑合併

本實作採用創新的**分離式路徑搜尋**方法，將複雜的雙球同步問題分解為兩個獨立的單球路徑搜尋問題，然後通過智能路徑合併來處理同步移動。

#### 1. 迷宮預處理與節點分類
```c
// 節點類型標記
- 牆壁: 1
- 死路: 4  
- 分支點: 5
- 目的地1: 8
- 目的地2: 9
```

**分支點識別**：
- 掃描迷宮中每個位置
- 計算相鄰可通行方向數量
- 1個方向 → 死路 (標記為4)
- 3個以上方向 → 分支點 (標記為5)

#### 2. 雙重BFS路徑搜尋
```c
// 分別為兩個球計算到所有目的地的路徑
for(int ct=0; ct<2; ct++){
    push_queue(&src[ct]);  // 將起點加入佇列
    // BFS搜尋到所有可能目的地的路徑
}
```

**路徑搜尋策略**：
- 從每個起點開始，使用BFS搜尋到所有分支點和目的地
- 記錄從起點到每個節點的最短路徑
- 使用`find_path()`函數沿著特定方向直線移動直到遇到分支點或目的地

#### 3. 智能路徑合併演算法
```c
// 選擇最佳球-目的地配對
if(dst[0][0].len_path + dst[1][1].len_path < dst[0][1].len_path + dst[1][0].len_path){
    // 球1→目的地1, 球2→目的地2
} else {
    // 球1→目的地2, 球2→目的地1
}
```

**合併策略**：
1. **配對選擇**：選擇總路徑長度最短的球-目的地配對
2. **同步移動**：從路徑末端開始，逐個動作合併兩條路徑
3. **衝突處理**：
   - 相同方向 → 同時移動
   - 不同方向但都可移動 → 移動其中一個
   - 移動會撞牆 → 移動另一個，並在另一路徑插入反向動作

#### 4. 關鍵資料結構
```c
typedef struct{
    int pt[2];           // 節點座標
    int len_path;        // 路徑長度
    char aval_road[4];   // 可用方向 (0:上, 1:右, 2:下, 3:左)
    char *path;          // 路徑記錄
} node;
```

**全域變數**：
- `src[2]`：兩個球的起點
- `dst[2][2]`：目的地節點（包含路徑資訊）
- `branch_point`：所有分支點的動態陣列
- `queue`：BFS搜尋用的佇列

#### 5. 演算法優勢
- **時間複雜度**：O(V + E)，其中V是分支點數量，E是連線數量
- **空間效率**：只儲存必要的分支點，避免完整狀態空間
- **路徑優化**：確保找到理論上的最優解
- **實作簡潔**：將複雜問題分解為可管理的子問題

### 實作細節

#### 座標轉換
```c
// 將輸入座標轉換為陣列索引
src[0].pt[0] = size_maze-1-src[0].pt[0];  // Y軸翻轉
```

#### 動態記憶體管理
```c
// 動態擴展分支點陣列
branch_point = realloc(branch_point, sizeof(node)*(++size_branch));
```

#### 路徑記錄與回溯
```c
// 記錄路徑並更新最短路徑
if(queue[0]->len_path + tmp_len < queue[size_queue-1]->len_path){
    queue[size_queue-1]->len_path = queue[0]->len_path + tmp_len;
    strcpy(queue[size_queue-1]->path, queue[0]->path);
    strcat(queue[size_queue-1]->path, tmp_path);
}
```

## 輸入格式
```
n                    // 迷宮大小 n×n
迷宮矩陣 (n行，每行n個數字)
ball1_x ball1_y ball2_x ball2_y  // 兩個球的起始位置
dest1_x dest1_y dest2_x dest2_y  // 兩個目的地位置
```

## 輸出格式
```
最短路徑長度
動作序列 (U=上, R=右, D=下, L=左)
```

## 範例
**輸入**：
```
11
1 1 1 1 1 1 1 1 1 1 1 
1 0 0 0 1 0 0 0 0 0 1 
1 0 1 0 1 0 1 1 1 0 1 
1 0 1 0 0 0 1 0 0 0 1 
1 0 1 1 1 1 1 0 1 1 1 
1 0 0 0 0 0 1 0 0 0 1 
1 0 1 1 1 1 1 1 1 0 1 
1 0 1 0 0 0 0 0 1 0 1 
1 1 1 0 1 1 1 0 1 0 1 
1 0 0 0 0 0 1 0 0 0 1 
1 1 1 1 1 1 1 1 1 1 1 
1 1 9 9
5 5 7 5
```

## 評分標準
- **基本分數**：75分（在截止日期前提交）
- **績效排名獎勵**：
  - [0%, 50%)：+0分
  - [50%, 75%)：+5分
  - [75%, 90%)：+9分
  - [90%, 95%)：+12分
  - [95%, 100%]：+15分
- **作業助理獎勵**：+10分（超級截止日期前提交）

## 檔案說明
- `411410006_hw1.c` - 主要實作檔案
- `1.in.txt`, `2.in.txt` - 測試輸入檔案
- `program1.pdf` - 作業說明文件
- `src_to_dst.png` - 迷宮示意圖

## 技術重點
- **分離式路徑搜尋**：將雙球問題分解為兩個獨立的單球路徑搜尋
- **迷宮預處理**：智能識別分支點和死路，優化搜尋空間
- **BFS圖形搜尋**：在分支點圖上進行最短路徑搜尋
- **智能路徑合併**：處理雙球同步移動的衝突和協調
- **動態記憶體管理**：使用realloc動態擴展分支點陣列
- **路徑回溯與優化**：記錄並更新最短路徑
- **座標系統轉換**：處理輸入座標與陣列索引的轉換
